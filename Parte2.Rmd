---
title: ""
author: "Gabriel Perez - gabrielmpp2@gmail.com"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---


# Parte 2 - Instalação de pacotes

Além dos recursos fornecidos no r-base, o R conta com mais de 10 mil pacotes disponíveis no CRAN e mais milhares disponíveis no Github. Os pacotes são essenciais para uma boa experiência com o R, pois podem:  
  

* facilitar a forma de programar;
  
    + dplyr (%>%)

* acelerar o tempo de processamento;  
  
    + gpuR   

    + Parallel
  
* melhorar os recursos gráficos;  
  
    + ggplot2
    + raster e rasterVis
    + fields
    + lattice e latticeExtra
  
* gerar modelos / resolver equações em uma linha de comando;  
  
    + caret
    + h2o
    + odesolve (equações diferenciais)
  
* diagramar notebooks como esse;  
  
    + RMarkdown
  
* integrar o R com outras linguagens;  
  
    + RCpp
    + RFortran
    + rJava
  
  
> Vamos visitar o CRAN: https://cran.r-project.org/  
  
## Instalando pacotes do CRAN  
  
Os pacotes disponíveis no CRAN são os mais fáceis de instalar, o comando para isso é:
  
```{r,eval=FALSE}
install.packages(pkgs="nome do pacote",lib="diretorio")

# e para remover temos o comando equivalente:
remove.packages(pkgs = "nome do pacote",lib="diretorio")
```
  
  
Tentem instalar o pacote "devtools".  
  
## Instalando pacotes via Github
  
O pacote devtools possibilita instalar pacotes diretamente do github. no github podemos encontrar pacotes que ainda não se encontram no CRAN ou baixar versões mais recentes e/ou em desenvolvimento.
  

```{r,eval=FALSE}
library(devtools)
install_github("nome do repositorio")

```
  
  
Em ocasiões muito específicas pode ser necessário compilar manualmente o código-fonte de algum pacote. Não vamos abordar essa situação pois cada pacote tem sua particularidade. Nesse caso o mais adequado é buscar um passo-a-passo na internet.

  

# Análise de exploratória em dados de estações do INMET
  
Para começarmos a fazer algumas análises estatísticas no R, vamos utilizar dados de estações automáticas do INMET. Os dados podem ser baixados no link abaixo:

> https://drive.google.com/open?id=1LLE61RbQ1EhFpwSSZzTsAIN0kbVSZwxw

Agora vamos criar um projeto no RStudio chamado "AnaliseINMET". Uma vez criado o projeto, vamos mover os dados baixados para um diretório chamado "dados" dentro do diretório do projeto. Dessa forma o acesso fica mais simples. Abra um novo script no projeto e salve com algum nome como "analise.R". Escolha uma estação e dentro do script, digite:  


```{r}
df_sp <- read.table("dados/inmet_saopaulo.txt",skip = 16, header = TRUE, sep = ";", row.names = NULL)

# se nossa tabela fosse um arquivo Excel, basta usar o comando read.csv

## digite somente "df_sp" no lugar do comando abaixo
kable(head(df_sp))

```
  
Surgiu uma coluna nomeada "X" com valores ausentes. Isso aconteceu pois o arquivo do INMET possui um último " ; " depois da última coluna de dados, e o R entende que depois dele virá uma nova coluna. Vamos removê-la:  
  
```{r}
df_sp$X <- NULL

## Vamos remover o número da estação que não será útil

df_sp$Estacao <- NULL
summary(df_sp)
```
  
Vamos fazer a média diária das variáveis. Para isso, vamos usar precisar manipular a coluna de datas.  É conveniente neste momento usar o comando `sapply`. Esse comando faz parte de uma família de comandos cujo o objetivo é aplicar uma função a um data.frame, lista ou vetor.  
  
> lapply e sapply  
  
Aplicam uma função a uma lista ou vetor. O `lapply` retorna uma lista e o `sapply` retorna um vetor.  
  
> apply  
  
Aplica uma função nas colunas ou linhas de um data.frame  
  
> mcapply
  
Vale ainda mencionar o `mcapply` da biblioteca parallel. Esse comando possui a mesma funcionalidade do apply e possibilita controlar quantos núcleos do processador serão utilizados
  

```{r}
# vamos criar colunas separadas para dia, mês e ano usando o strsplit e o sapply

# primeiro testem o comando strsplit e vejam a saída, removam o # da linha abaixo
# strsplit(x = as.character(df_sp$Data),split = "/")

df_sp$mes <- sapply(strsplit(x = as.character(df_sp$Data),split = "/"),FUN = '[',2)
df_sp$ano <- sapply(strsplit(x = as.character(df_sp$Data),split = "/"),FUN = '[',3)

# podemos escrever  o mesmo comando usando a sintaxe com %>%, muitos usuários
# argumentam que essa sintaxe possui mais clareza

library(dplyr)
df_sp$mes <- df_sp$Data %>% as.character() %>% strsplit(split="/") %>% sapply(FUN='[',2)
df_sp$ano <- df_sp$Data %>% as.character() %>% strsplit(split="/") %>% sapply(FUN='[',3)

```
  
  
Agora temos a data separada em colunas, podemos fazer médias diárias, mensais e anuais. Para isso podemos usar o comando `aggregate`.  A função aggregate aceita objetos do tipo __fórmula__ como padrão de agregamento. Veja `help(stats::aggregate)`.
  
```{r}
temp_mensal <- aggregate(TempBulboSeco ~ mes + ano, data = df_sp, mean)
kable(temp_mensal) #digite somente temp_mensal 
plot(temp_mensal)
plot(temp_mensal$TempBulboSeco,type="l")
```

Agora vamos colocar as datas no eixo X e arrumar os nomes dos eixos.  
  
```{r}
datas <- seq(as.Date("1998-01-01"),as.Date("2017-12-31"),by="month")
plot(x=datas, y=temp_mensal$TempBulboSeco, xlab = "Data", ylab = "Temperatura ºC",type = "l")
```

___Exercício___ 
  
Faça o mesmo processo para obter um vetor com as médias diárias e um vetor com a temperatura média de cada mês (12 valores). Faça os plots correspondentes com as datas no eixo x.  
  
## Transformada de Fourier
  
Os plots preliminares revelam que existem oscilações periódicas nas variáveis observadas. É natural tentar entender quais são as frequências dominantes nessas séries temporais.  
  
Vamos explorar a função nativa do r `spec.pgram`:
```{r}
help("spec.pgram")

```
  
  
Notem que a função `spec.pgram` espera como entrada uma variável do tipo "time series". Vamos transformar nosso vetor de observações em uma variável `ts`.  
  

```{r}
ts_temp_sp <- ts(temp_mensal$TempBulboSeco,start = 1998, end = 2018, frequency = 12) 
class(ts_temp_sp)
plot(ts_temp_sp) # Note que ao plotar uma variável ts o eixo x já recebe corretamente as datas

# É uma boa prática normalizar a ts antes de fazer a transformada de foutier
ts_temp_sp <- (ts_temp_sp - mean(ts_temp_sp)) / max(ts_temp_sp)
fft_temp <- spec.pgram(ts_temp_sp, frequency  = 12, plot=FALSE)

# Vamos examinar o objeto fft_temp
fft_temp

# O objeto é uma lista onde "spec" contém a potência de cada frequência "freq"
# Para obter o período basta inverter a frequência

fft_temp$period <- 1/fft_temp$freq

plot(x = fft_temp$period, y = fft_temp$spec,type = "l")

# Por último, vamos criar um data.frame com as informações relevantes da transformada

df_fft_temp <- data.frame(period = fft_temp$period, spec = fft_temp$spec)

```
  
  
Naturalmente, o plot mostra que o período anual é o mais importante para a temperatura. No entanto, vamos gerar uma tabela com os períodos mais importantes em ordem decrescente.  
  
> Tarefa: Vamos procurar no Google como ordenar uma tabela no R usando os valores de uma coluna. Queremos ordenar
> nossa tabela fft_temp com a coluna spec

```{r,echo=FALSE,eval=FALSE}
"how to sort a dataframe by columns in R - stackoverflow"
```

> O que os períodos mais energéticos podem nos dizer?

```{r,echo=FALSE}
library(plyr); library(dplyr)


kable(head(arrange(df_fft_temp, desc(spec)),10))

```





## Matriz de correlação
  
## Regressão linear 


FALAR DE APPLY, LAPPLY, MCLAPPLY (Parallel)

cores<-detectCores()
pause <- function(i) {
  function(x) Sys.sleep(i)
}

system.time(lapply(1:10, pause(0.25)))
system.time(mclapply(1:10, pause(0.25), mc.cores = cores))


olhar byte code compilation
# Referências
http://material.curso-r.com
http://adv-r.had.co.nz/ 

falar de apply labbly mapply
